name: 'Deploy Docker to AWS (EC2)'
description: 'Deploy a Docker app to an AWS Virtual Machine (EC2) with Docker Compose'
branding:
  icon: upload-cloud
  color: red
inputs:
  # Checkout
  checkout:
    description: 'Specifies if this action should checkout the code'
    required: false
    default: 'true'
  
  # AWS
  aws_access_key_id:
    description: 'AWS access key ID'
    required: true
  aws_secret_access_key:
    description: 'AWS secret access key'
    required: true
  aws_session_token:
    description: 'AWS session token'
    required: false
  aws_default_region:
    description: 'AWS default region'
    default: us-east-1
    required: false
  aws_ami_id:
    description: 'AWS AMI ID. Will default to the latest Ubuntu 22.04 server image (HVM) '
    required: false
  aws_ami_update:
    description: 'Set this to true if you want to recreate the EC2 instance if there is a newer version of the AMI.'
    required: false
  tf_state_bucket:
    description: 'AWS S3 bucket to use for Terraform state. Defaults to `${org}-${repo}-{branch}-tf-state`'
    required: false
  tf_state_bucket_destroy:
    description: 'Force purge and deletion of S3 bucket defined. Any file contained there will be destroyed. `stack_destroy` must also be `true`'
    required: false
    default: 'false'
  aws_resource_identifier:
    description: 'Set to override the AWS resource identifier for the deployment.  Defaults to `${org}-{repo}-{branch}`.  Use with destroy to destroy specific resources.'
  
  # ENV files
  repo_env:
    description: 'File containing environment variables to be used with the app'
    required: false
    default: 'repo_env'
  dot_env:
    description: '`.env` file to be used with the app from Github secrets'
    required: false
  ghv_env:
    description: '`.env` file to be used with the app from Github variables'
    required: false
  aws_secret_env:
    description: 'Secret name to pull env variables from AWS Secret Manager'
    required: false
    default: ''
  
  # Application
  app_directory:
    description: 'Relative path for the directory of the app (i.e. where `Dockerfile` and `docker-compose.yaml` files are located). This is the directory that is copied to the EC2 instance.  Default is the root of the repo.'
  app_port:
    description: 'Port to expose for the app'
    required: false
  lb_port:
    description: 'Load balancer listening port. Defaults to 80 if NO FQDN provided, 443 if FQDN provided'
    default: 3000
    required: false
  lb_healthcheck: 
    description: 'Load balancer health check string. Defaults to HTTP:app_port'
    required: false
  
  # EC2 Instance
  ec2_instance_profile:
    description: 'The AWS IAM instance profile to use for the EC2 instance'
  ec2_instance_type: 
    description: 'The AWS Instance type'
    default: t2.small
    required: false
  ec2_instance_protect:
    description: 'Set this to true to enable instance deletion protection.'
    required: false
  ec2_volume_size: 
    description: 'The size of the volume (in GB) on the AWS Instance'
    required: false
    default: "8"
  
  # EFS
  aws_create_efs:
    description: "Toggle to indicate whether to create and EFS and mount it to the ec2 as a part of the provisioning. Note: The EFS will be managed by the stack and will be destroyed along with the stack"
  aws_create_ha_efs:
    description: Toggle to indicate whether the EFS resource should be highly available (target mounts in all available zones within region)
  aws_create_efs_replica:
    description: Toggle to indiciate whether a read-only replica should be created for the EFS primary file system
  aws_enable_efs_backup_policy:
    description: Toggle to indiciate whether the EFS should have a backup policy, default is `false`
  aws_efs_zone_mapping:
    description: Information on Zone Mapping can be found in the [README.md](README.md#efs-zone-mapping)
  aws_efs_transition_to_inactive:
    description: Indicates how long it takes to transition files to the IA storage class
  aws_replication_configuration_destination:
    description: "AWS Region to target for replication"
  aws_mount_efs_id:
    description: ID of existing EFS
  aws_mount_efs_security_group_id:
    description: ID of the primary security group used by the existing EFS
  
  # Stack management
  stack_destroy:
    description: 'Set to "true" to Destroy the stack. Will delete the elb_logs bucket after the destroy action runs.'
  
  # Domains
  domain_name:
    description: 'Define the root domain name for the application. e.g. app.com'
    required: false
  sub_domain:
    description: 'Define the sub-domain part of the URL. Defaults to `${org}-${repo}-{branch}`'
  root_domain:
    description: 'Deploy to root domain. Will generate two DNS recrods, one for root, another for www'
    required: false
  cert_arn:
    description: 'Define the certificate ARN to use for the application'
    required: false
  create_root_cert:
    description: 'Generates and manage the root cert for the application'
    required: false
  create_sub_cert: 
    description: 'Generates and manage the sub-domain certificate for the application'
    required: false
  no_cert:
    description: 'Makes the application not to use a certificate by disabling certificate lookup.'
    required: false
    default: false
    
  # Terraform
  targets:
    description: 'A list of targets to create before the full stack creation. Example: `'
  additional_tags:
    description: 'A JSON object of additional tags that will be included on created resources. Example: `{"key1": "value1", "key2": "value2"}`'
    required: false
   
  # Secret Manager
  create_keypair_sm_entry:
    required: false
    description: "Generates and manages a secret manager entry that contains the public and private keys created for the ec2 instance."
    default: false
    
  # RDS
  aws_enable_postgres:
    description: Set to "true" to enable a postgres database
    required: false
  aws_postgres_engine: 
    description: Which Database engine to use
    required: false
  aws_postgres_engine_version:
    description: Specify Postgres version 
    required: false
  aws_postgres_instance_class:
    description: Define the size of the instances in the DB cluster
    required: false
  aws_postgres_subnets:
    description: 'Specify which subnets to use as a list of strings.  Example: `i-1234,i-5678,i-9101`'
    required: false
  aws_postgres_database_name:
    description: 'Specify a database name. Will be created if it does not exist'
    required: false
    # TODO: create another user and point to that instead
  aws_postgres_database_port:
    description: 'Postgres database port'
    required: false
  
  # Ansible
  application_mount_target:
    description: "Directory path in application env to mount directory, default is `data`"
    default: data
  data_mount_target:
    description: "Directory path within docker env to mount directory to, default is `/data`"
  efs_mount_target:
    description: "Directory path in efs to mount directory to, default is `/`"

outputs:
  vm_url:
    description: "The URL of the generated app"
    value: ${{ steps.deploy.outputs.vm_url }}

runs:
  using: 'composite'
  steps:
    - name: Invert boolean Variable
      shell: bash
      id: set-cert
      if: ${{ inputs.no_cert == 'false' }}
      run: echo "enable_cert=true" >> $GITHUB_OUTPUT
      
      
    - name: Deploy with BitOps
      id: deploy
      uses: bitovi/github-actions-commons@13-add-support-to-add-terraform-ansible-code
      with:
        # Current repo vars
        gh_action_repo: ${{ github.action_path }}

        # Action main inputs
        checkout: ${{ inputs.checkout }}
        tf_stack_destroy: ${{ inputs.stack_destroy }}
        tf_state_bucket: ${{ inputs.tf_state_bucket }}
        tf_state_bucket_destroy: ${{ inputs.tf_state_bucket_destroy }}
        tf_state_bucket_provider: 'aws'
        tf_targets: ${{ inputs.targets }}


        # AWS
        aws_access_key_id: ${{ inputs.aws_access_key_id }}
        aws_secret_access_key: ${{ inputs.aws_secret_access_key }}
        aws_session_token: ${{ inputs.aws_session_token }}
        aws_default_region: ${{ inputs.aws_default_region }}
        aws_resource_identifier: ${{ inputs.aws_resource_identifier }}
        aws_additional_tags: ${{ inputs.additional_tags }}

        # ENV
        env_aws_secret: ${{ inputs.aws_secret_env }}
        env_repo: ${{ inputs.repo_env }}
        env_ghs: ${{ inputs.dot_env }}
        env_ghv: ${{ inputs.ghv_env }}

        # EC2
        aws_ec2_instance_create: true
        aws_ec2_ami_id: ${{ inputs.aws_ami_id }}
        aws_ec2_ami_update: ${{ inputs.aws_ami_update }}
        aws_ec2_iam_instance_profile: ${{ inputs.ec2_instance_profile }}
        aws_ec2_instance_type: ${{ inputs.ec2_instance_type }}
        aws_ec2_instance_protect: ${{ inputs.ec2_instance_protect }}
        aws_ec2_instance_root_vol_size: ${{ inputs.ec2_volume_size }}
        aws_ec2_create_keypair_sm: ${{ inputs.create_keypair_sm_entry }}
        aws_ec2_instance_public_ip: true

        # AWS Route53 Domains abd Certificates
        aws_r53_enable: true
        aws_r53_domain_name: ${{ inputs.domain_name }}
        aws_r53_sub_domain_name: ${{ inputs.sub_domain }}
        aws_r53_root_domain_deploy: ${{ inputs.root_domain }}
        aws_r53_enable_cert: ${{ steps.set-cert.outputs.enable_cert }}
        aws_r53_cert_arn: ${{ inputs.cert_arn }}
        aws_r53_create_root_cert: ${{ inputs.create_root_cert }}
        aws_r53_create_sub_cert: ${{ inputs.create_sub_cert }}

        # AWS ELB
        aws_elb_create: true
        aws_elb_app_port: ${{ inputs.app_port }}
        aws_elb_listen_port: ${{ inputs.lb_port }}
        aws_elb_healthcheck: ${{ inputs.lb_healthcheck }}

        # AWS EFS
        aws_efs_create: ${{ inputs.aws_create_efs }}
        aws_efs_create_ha: ${{ inputs.aws_create_ha_efs }}
        aws_efs_create_replica: ${{ inputs.aws_create_efs_replica }}
        aws_efs_enable_backup_policy: ${{ inputs.aws_enable_efs_backup_policy }}
        aws_efs_zone_mapping: ${{ inputs.aws_efs_zone_mapping }}
        aws_efs_transition_to_inactive: ${{ inputs.aws_efs_transition_to_inactive }}
        aws_efs_replication_destination: ${{ inputs.aws_replication_configuration_destination }}
        aws_efs_mount_id: ${{ inputs.aws_mount_efs_id }}
        aws_efs_mount_security_group_id: ${{ inputs.aws_mount_efs_security_group_id }}
        aws_efs_ec2_mount_point: ${{ inputs.application_mount_target }}
        aws_efs_mount_target: ${{ inputs.efs_mount_target }}

        # POSTGRES
        aws_postgres_enable: ${{ inputs.aws_enable_postgres }}
        aws_postgres_engine:  ${{ inputs.aws_postgres_engine }}
        aws_postgres_engine_version:  ${{ inputs.aws_postgres_engine_version }}
        aws_postgres_instance_class: ${{ inputs.aws_postgres_instance_class }}
        aws_postgres_subnets: ${{ inputs.aws_postgres_subnets }}
        aws_postgres_database_name: ${{ inputs.aws_postgres_database_name }}
        aws_postgres_database_port: ${{ inputs.aws_postgres_database_port}}

        # DOCKER
        docker_install: true
        docker_repo_app_directory: ${{ inputs.app_directory }}
        docker_efs_mount_target: ${{ inputs.data_mount_target }}
